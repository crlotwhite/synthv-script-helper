{
    "clearAll": {
        "prefix": "clearAll() → {boolean}",
        "body": "clearAll()",
        "description": "Unselects all object types supported by this selection state. Return true if the selection has changed."
    },
    "clearGroups": {
        "prefix": "clearGroups() → {boolean}",
        "body": "clearGroups()",
        "description": "Unselect all **NoteGroupReference**. Return true if the selection has changed."
    },
    "getIndexInParent": {
        "prefix": "getIndexInParent() → {number}",
        "body": "getIndexInParent()",
        "description": "Get index of the current object in its parent. In Lua, this index starts from 1. In JavaScript, this index starts from 0."
    },
    "getparent": {
        "prefix": "getParent() → {NestedObject|undefined}",
        "body": "getparent()",
        "description": "Get the parent NestedObject. Return undefined if the current object is not attached to a parent."
    },
    "getSelectedGroups": {
        "prefix": "getSelectedGroups() → {array}",
        "body": "getSelectedGroups()",
        "description": "Get an array of selected NoteGroupReference following the order of selection."
    },
    "hasSelectedContent": {
        "prefix": "hasSelectedContent() → {boolean}",
        "body": "hasSelectedContent()",
        "description": "Check if there's anything selected."
    },
    "hasSelectedGroups": {
        "prefix": "hasSelectedGroups() → {boolean}",
        "body": "hasSelectedGroups()",
        "description": "Check if there is at least one NoteGroupReference selected."
    },
    "hasUnfinishedEdits": {
        "prefix": "hasUnfinishedEdits() → {boolean}",
        "body": "hasUnfinishedEdits()",
        "description": "Check if there's any unfinished edit on the selected objects."
    },
    "isMemoryManaged": {
        "prefix": "isMemoryManaged() → {boolean}",
        "body": "isMemoryManaged()",
        "description": "Check whether or not the current object is memory managed (i.e. garbage collected by the script environment)."
    },
    "getParent": {
        "prefix": "selectGroup(reference)",
        "body": "selectGroup(${1:Reference})",
        "description": "Add a NoteGroupReference to the selection. The argument must be part of the currently open project."
    },
    "unselectGroup": {
        "prefix": "unselectGroup(reference) → {boolean}",
        "body": "unselectGroup(${1:Reference})",
        "description": "Unselect a NoteGroupReference. Return true if the selection has changed."
    },
    "getNavigation": {
        "prefix": "getNavigation() → {CoordinateSystem}",
        "body": "getNavigation()",
        "description": "Get the coordinate system for the track arrangement area."
    },
    "getSelection": {
        "prefix": "getParent() → {NestedObject|undefined}",
        "body": "getSelection()",
        "description": "Get the parent NestedObject. Return undefined if the current object is not attached to a parent."
    },
    "add": {
        "prefix": "add(b, v) → {boolean}",
        "body": "add(${1:b}, ${2:v})",
        "description": "Add a control point with position b (blicks) and parameter value v. If there is already a point on b, the parameter value will get updated to v. Return true if a new point has been created."
    },
    "clone": {
        "prefix": "clone() → {Automation}",
        "body": "clone()",
        "description": "A deep copy of the current object."
    },
    "get": {
        "prefix": "get(b) → {number}",
        "body": "get(${1:b})",
        "description": "Get the interpolated parameter value at position b (blicks). If a point exists at b, the interpolation is guaranteed to return the value for the point, regardless of the interpolation method."
    },
    "getAllPoints": {
        "prefix": "getAllPoints() → {array}",
        "body": "getAllPoints()",
        "description": "A version of Automation#getPoints with unlimited range."
    },
    "getDefinition": {
        "prefix": "getDefinition() → {object}",
        "body": "getDefinition()",
        "description": "Get a definition object with the following properties; displayName, typeName, range, defaultValue."
    },
    "getInterpolationMethod": {
        "prefix": "getInterpolationMethod() → {string}",
        "body": "getInterpolationMethod()",
        "description": "Returns how values between control points are interpolated: Linear, Cosine, Cubic"
    },
    "getLinear": {
        "prefix": "getLinear(b) → {number}",
        "body": "getLinear(${1:b})",
        "description": "A version of Automation#get that uses linear interpolation (even if Automation#getInterpolationMethod is not \"Linear\")."
    },
    "getPoints": {
        "prefix": "getPoints(begin, end) → {array}",
        "body": "getPoints(${1:begin}, ${2:end})",
        "description": "Get an array of control points whose positions are between begin and end (blicks). Each element in the array is an array of two elements: a number for the position (blicks) and a number for the parameter value. For example, [[0, 0.1], [5000, 0], [10000, -0.1]]."
    },
    "getType": {
        "prefix": "getType() → {string}",
        "body": "getType()",
        "description": "Get the parameter type for this Automation. See the typeName column of the table in Automation#getDefinition."
    },
    "remove": {
        "prefix": "remove(b) → {boolean}",
        "body": "remove(${1:b})",
        "description": "Remove the control point at position b (blicks) if there is one. Return true if any point has been removed."
    },
    "removeba": {
        "prefix": "remove(begin, end) → {boolean}",
        "body": "remove(${1:begin}, ${2:end})",
        "description": "Remove all control points between position begin (blicks) and end (blicks). Return true if any point has been removed; return false if there's no point in the specified range."
    },
    "removeAll": {
        "prefix": "removeAll",
        "body": "removeAll()",
        "description": "Remove all control points in the Automation."
    },
    "simplify": {
        "prefix": "simplify(begin, end, threshold) → {boolean}",
        "body": "simplify(${1:begin}, ${2:end}, ${3:threshold})",
        "description": "Simplify the parameter curve from position begin (blicks) to position end (blicks) by removing control points that do not significantly contribute to the curve's shape. If threshold is not provided, it will be set to 0.002. Higher values of threshold will result in more simplification. Return true if any point has been removed."
    },
    "getTimePxPerUnit": {
        "prefix": "getTimePxPerUnit() → {number}",
        "body": "getTimePxPerUnit()",
        "description": "SV-获取水平方向的缩放因子"
    },
    "getTimeViewRange": {
        "prefix": "getTimeViewRange",
        "body": "getTimeViewRange()",
        "description": "Get the scaling factor in the horizontal direction. The unit is pixels per blick so expect this to be a very small number."
    },
    "getValuePxPerUnit": {
        "prefix": "getValuePxPerUnit() → {number}",
        "body": "getValuePxPerUnit()",
        "description": "Get the scaling factor in the vertical direction. For the piano roll, the unit is pixels per semitone."
    },
    "getValueViewRange": {
        "prefix": "getValueViewRange() → {array}",
        "body": "getValueViewRange()",
        "description": "Get the current visible value range. It returns an array with two number elements corresponding to the lower value and upper value. For the piano roll, the unit is MIDI number (semitones); for arrangement view, its value bears no meaning."
    },
    "setTimeLeft": {
        "prefix": "setTimeLeft(time)",
        "body": "setTimeLeft(${1:time})",
        "description": "Move the visible area so the left end is at time."
    },
    "setTimeRight": {
        "prefix": "setTimeRight(time)",
        "body": "setTimeRight(${1:time})",
        "description": "Move the visible area so the right end is at time."
    },
    "setTimeScale": {
        "prefix": "setTimeScale(scale)",
        "body": "setTimeScale(${1:scale})",
        "description": "Set the horizontal scaling factor to scale. The unit is pixels per blick so it expects a very small number."
    },
    "setValueCenter": {
        "prefix": "setValueCenter(v)",
        "body": "setValueCenter(${1:v})",
        "description": "Move the visible area so the vertical center is at v."
    },
    "snap": {
        "prefix": "snap(b) → {number}",
        "body": "snap(${1:b})",
        "description": "Round a time position b based on snapping settings."
    },
    "t2x": {
        "prefix": "t2x(t) → {number}",
        "body": "t2x(${1:t})",
        "description": "Convert a time position to an x-position (pixels)."
    },
    "v2y": {
        "prefix": "v2y(v) → {number}",
        "body": "v2y(${1:v})",
        "description": "Convert a value to a y-position (pixels)."
    },
    "x2t": {
        "prefix": "x2t(x) → {number}",
        "body": "x2t(${1:x})",
        "description": "Convert an x-position (pixels) to a time position."
    },
    "y2v": {
        "prefix": "y2v(y) → {number}",
        "body": "y2v(${1:y})",
        "description": "Convert a y-position (pixels) to a value."
    },
    "getCurrentGroup": {
        "prefix": "getCurrentGroup() → {NoteGroupReference}",
        "body": "getCurrentGroup()",
        "description": "Get the current NoteGroupReference that the user is working inside. If the user has not entered a NoteGroupReference, return the main group of the current track."
    },
    "getCurrentTrack": {
        "prefix": "getCurrentTrack() → {Track}",
        "body": "getCurrentTrack()",
        "description": "Get the current Track opened in the piano roll."
    },
    "getAttributes": {
        "prefix": "getAttributes() → {object}",
        "body": "getAttributes()",
        "description": "Get an object holding note properties."
    },
    "getDuration": {
        "prefix": "getDuration() → {number}",
        "body": "getDuration()",
        "description": "Get the duration of the note. The unit is blicks."
    },
    "getEnd": {
        "prefix": "getEnd() → {number}",
        "body": "getEnd()",
        "description": "Get the end position (start + duration) of the note. The unit is blicks."
    },
    "getLyrics": {
        "prefix": "getLyrics() → {string}",
        "body": "getLyrics()",
        "description": "Get the lyrics for this note."
    },
    "getOnset": {
        "prefix": "getOnset() → {number}",
        "body": "getOnset()",
        "description": "Get the start position of the note. The unit is blicks."
    },
    "getPhonemes": {
        "prefix": "getPhonemes() → {string}",
        "body": "getPhonemes()",
        "description": "Returns the user-specified phonemes, delimited by spaces. For example, \"hh ah ll ow\". If there's no phoneme specified, this will return an empty string, instead of the default pronunciation"
    },
    "getPitch": {
        "prefix": "getPitch() → {number}",
        "body": "getPitch()",
        "description": "Get the pitch as a MIDI number. C4 maps to 60."
    },
    "setAttributes": {
        "prefix": "setAttributes(object)",
        "body": "setAttributes()",
        "description": "Set note properties based on an attribute object. The attribute object does not have to be complete; only the given properties will be updated."
    },
    "setDuration": {
        "prefix": "setDuration(t)",
        "body": "setDuration(${1:t})",
        "description": "Resize the note to duration t. The unit is blicks. This changes the end as well, but not the onset."
    },
    "setLyrics": {
        "prefix": "setLyrics(lyrics)",
        "body": "setLyrics(${1:lyrics})",
        "description": "Change the lyrics."
    },
    "setOnset": {
        "prefix": "setOnset(t)",
        "body": "setOnset(${1:t})",
        "description": "Move the note to start at t. The unit is blicks. This does not change the duration."
    },
    "setPhonemes": {
        "prefix": "setPhonemes(phoneme_str)",
        "body": "setPhonemes(${1:phoneme_str})",
        "description": "Change the phonemes to phoneme_str. For example, \"hh ah ll ow\"."
    },
    "setPitch": {
        "prefix": "setPitch(pitchNumber)",
        "body": "setPitch(${1:pitchNumber})",
        "description": "Set the note pitch to pitchNumber, a MIDI number."
    },
    "setTimeRange": {
        "prefix": "setTimeRange(onset, duration)",
        "body": "setTimeRange(${1:onset},${2:duration})",
        "description": "Set both onset and duration. This is a shorthand for calling setOnset(onset) and setDuration(duration)."
    },
    "addNote": {
        "prefix": "addNote(note) → {number}",
        "body": "addNote(${1:note})",
        "description": "Add a note to this NoteGroup and return the index of the added note. The notes are kept sorted by ascending onset positions."
    },
    "getName": {
        "prefix": "getName() → {string}",
        "body": "getName()",
        "description": "Get the user-specified name of this NoteGroup."
    },
    "getNote": {
        "prefix": "getNote(index) → {Note}",
        "body": "getNote()",
        "description": "Get the note at index. The notes inside a NoteGroup are always sorted by onset positions."
    },
    "getNumNotes": {
        "prefix": "getNumNotes() → {number}",
        "body": "getNumNotes()",
        "description": "Get the number of notes in the NoteGroup."
    },
    "getParameter": {
        "prefix": "getParameter(type) → {Automation}",
        "body": "getParameter((${1:type})",
        "description": "Get the Automation object for parameter type. It is case-insensitive. type should be one of the strings in the typeName column in the table shown in Automation#getDefinition."
    },
    "getUUID": {
        "prefix": "getUUID() → {string}",
        "body": "getUUID()",
        "description": "Get the Universally Unique Identifier. Unlike the name, a UUID is unique across the project and can be used to associate a NoteGroupReference with a NoteGroup."
    },
    "removeNote": {
        "prefix": "removeNote(index)",
        "body": "removeNote(${1:index})",
        "description": "Remove the note at index."
    },
    "setName": {
        "prefix": "setName(name)",
        "body": "setName(${1:name})",
        "description": "Set the name of this NoteGroup."
    },
    "getPitchOffset": {
        "prefix": "getPitchOffset() → {number}",
        "body": "getPitchOffset()",
        "description": "Get the pitch shift (semitones) applied to all notes in the target NoteGroup."
    },
    "getTarget": {
        "prefix": "getTarget() → {NoteGroup}",
        "body": "getTarget()",
        "description": "Get the target NoteGroup."
    },
    "getTimeOffset": {
        "prefix": "getTimeOffset() → {number}",
        "body": "getTimeOffset()",
        "description": "Get the time offset (blicks) applied to all notes in the target NoteGroup."
    },
    "getVoice": {
        "prefix": "getVoice() → {object}",
        "body": "getVoice()",
        "description": "Get an object holding the default voice properties for this group, similar to Note#getAttributes."
    },
    "isInstrumental": {
        "prefix": "isInstrumental() → {boolean}",
        "body": "isInstrumental()",
        "description": "Whether this NoteGroupReference refers to an external audio file. If so, it must not refer to a NoteGroup."
    },
    "isMain": {
        "prefix": "isMain() → {boolean}",
        "body": "isMain()",
        "description": "Whether this NoteGroupReference refers to the parent Track's main group."
    },
    "setPitchOffset": {
        "prefix": "setPitchOffset(pitchOffset)",
        "body": "setPitchOffset(${1:pitchOffset})",
        "description": "Set the pitch offset to pitchOffset (semitones)."
    },
    "setTarget": {
        "prefix": "setTarget(group)",
        "body": "setTarget(${1:group})",
        "description": "Set the target NoteGroup. Note that once set, the target can't be changed."
    },
    "setTimeOffset": {
        "prefix": "setTimeOffset(blickOffset)",
        "body": "setTimeOffset(${1:blickOffset})",
        "description": "Set the time offset to blickOffset (blicks)."
    },
    "setVoice": {
        "prefix": "setVoice(attributes)",
        "body": "setVoice()",
        "description": "Set voice properties based on an attribute object (for the definition, see NoteGroupReference#getVoice). The attribute object does not have to be complete; only the given properties will be updated (see Note#setAttributes)."
    },
    "getPlayhead": {
        "prefix": "getPlayhead() → {number}",
        "body": "getPlayhead()",
        "description": "Get the current playhead position in seconds. To get the position in blicks, use this with the current project's TimeAxis."
    },
    "getStatus": {
        "prefix": "getStatus() → {string}",
        "body": "getStatus()",
        "description": "Get the current playback status. It can be one of the following; playing, looping, stopped."
    },
    "loop": {
        "prefix": "loop(tBegin, tEnd)",
        "body": "loop(${1:tBegin}, ${2:tEnd})",
        "description": "Start looping between tBegin and tEnd in seconds."
    },
    "pause": {
        "prefix": "pause()",
        "body": "pause()",
        "description": "Stop playing but without resetting the playhead."
    },
    "play": {
        "prefix": "play()",
        "body": "play()",
        "description": "Start playing audio."
    },
    "seek": {
        "prefix": "seek(t)",
        "body": "seek()",
        "description": "Set the playhead position to t in seconds. If the audio is playing, this does not pause the audio but resumes playing at the new position."
    },
    "stop": {
        "prefix": "stop()",
        "body": "stop()",
        "description": "Stop playing and reset the playhead to where the playback started."
    },
    "addNoteGroup": {
        "prefix": "addNoteGroup(group, suggestedIndex) → {number}",
        "body": "addNoteGroup(${1:group}, ${2:suggestedIndex})",
        "description": "Insert a NoteGroup to the project library at suggestedIndex. If suggestedIndex is not given, the NoteGroup is added at the end. Return the index of the added NoteGroup."
    },
    "addTrack": {
        "prefix": "Add a Track to the Project. Return the index of the added Track.",
        "body": "addTrack()",
        "description": "Add a Track to the Project. Return the index of the added Track."
    },
    "getFileName": {
        "prefix": "getFileName() → {string}",
        "body": "getFileName()",
        "description": "Get the absolute path of the project on the file system."
    },
    "getNoteGroup": {
        "prefix": "getNoteGroup(id) → {NoteGroup|undefined}",
        "body": "getNoteGroup(${1:id})",
        "description": "If id is a number, get the id-th NoteGroup in the project library. If id is a string, look for a NoteGroup in the project library with id as its UUID; return undefined if no such NoteGroup exists."
    },
    "getNumNoteGroupsInLibrary": {
        "prefix": "getNumNoteGroupsInLibrary() → {number}",
        "body": "getNumNoteGroupsInLibrary()",
        "description": "Get the number of NoteGroup in the project library. It does not count the main groups and is unrelated to the number of NoteGroupReference."
    },
    "getNumTracks": {
        "prefix": "getNumTracks() → {number}",
        "body": "getNumTracks()",
        "description": "Get the number of tracks."
    },
    "getTimeAxis": {
        "prefix": "getTimeAxis() → {TimeAxis}",
        "body": "getTimeAxis()",
        "description": "Get the TimeAxis object of this Project."
    },
    "getTrack": {
        "prefix": "getTrack(index) → {Track}",
        "body": "getTrack(${1:index})",
        "description": "Get the index-th Track. The indexing is based on the storage order rather than display order."
    },
    "newUndoRecord": {
        "prefix": "newUndoRecord()",
        "body": "newUndoRecord()",
        "description": "Add a new undo record for this Project. This means that all edits following the last undo record will be undone/redone together when the users press Ctrl + Z or Ctrl + Y."
    },
    "removeNoteGroup": {
        "prefix": "removeNoteGroup(index)",
        "body": "removeNoteGroup(${1:index})",
        "description": "Remove index-th NoteGroup from the project library. This also removes all NoteGroupReference that refer to the NoteGroup."
    },
    "removeTrack": {
        "prefix": "removeTrack(index)",
        "body": "removeTrack(${1:index})",
        "description": "Remove the index-th Track from the Project."
    },
    "blackKey": {
        "prefix": "blackKey(k) → {boolean}",
        "body": "blackKey(${1:k})",
        "description": "Check whether the key (passed in as a MIDI number) is a black key on a piano. Conversions between musical and physical time in the context of a project are done by TimeAxis."
    },
    "blick2Quarter": {
        "prefix": "blick2Quarter(b) → {number}",
        "body": "blick2Quarter(${1:b})",
        "description": "Convert b from number of blicks into number of quarters. Equivalent to b / SV.QUARTER. Conversions between musical and physical time in the context of a project are done by TimeAxis."
    },
    "blick2Seconds": {
        "prefix": "blick2Seconds(b, bpm) → {number}",
        "body": "blick2Seconds(${1:b},${2:bpm})",
        "description": "Convert b from blicks into seconds with the specified beats per minute bpm. Equivalent to b / SV.QUARTER * 60 / bpm. Conversions between musical and physical time in the context of a project are done by TimeAxis."
    },
    "blickRoundDiv": {
        "prefix": "blickRoundDiv(dividend, divisor) → {number}",
        "body": "blickRoundDiv(${1:dividend},${2:divisor})",
        "description": "Rounded division of dividend (blicks) over divisor (blicks). Conversions between musical and physical time in the context of a project are done by TimeAxis."
    },
    "blickRoundTo": {
        "prefix": "blickRoundTo(b, interval) → {number}",
        "body": "blickRoundTo(${1:b},${2:interval})",
        "description": "Returns the closest multiple of interval (blicks) from b (blick). Equivalent to blickRoundDiv(b, interval) * interval. Conversions between musical and physical time in the context of a project are done by TimeAxis."
    },
    "create": {
        "prefix": "create(type) → {object}",
        "body": "create(${1:type})",
        "description": "Create a new object. type can be one of the following type-specifying strings."
    },
    "freq2Pitch": {
        "prefix": "freq2Pitch(f) → {number}",
        "body": "freq2Pitch()",
        "description": "Convert a frequency in Hz to a MIDI number (semitones, where C4 is 60). Conversions between musical and physical time in the context of a project are done by TimeAxis."
    },
    "getHostClipboard": {
        "prefix": "getHostClipboard() → {string}",
        "body": "getHostClipboard()",
        "description": "Get the text on the system clipboard."
    },
    "getArrangement": {
        "prefix": "getArrangement() → {ArrangementView}",
        "body": "getArrangement()",
        "description": "Get the UI state object for arrangement view."
    },
    "getHostInfo": {
        "prefix": "getHostInfo() → {object}",
        "body": "getHostInfo()",
        "description": "Get an object with the following properties; osType, osName, hostName, hostVersion, hostVersionNumber, languageCode."
    },
    "getMainEditor": {
        "prefix": "getMainEditor() → {MainEditorView}",
        "body": "getMainEditor(${1:group})",
        "description": "Get the UI state object for the piano roll."
    },
    "getPhonemesForGroup": {
        "prefix": "getPhonemesForGroup(group) → {array}",
        "body": "getPhonemesForGroup()",
        "description": "Get the phonemes for all notes in a group (passed in as a group reference). The group must be part of the currently open project."
    },
    "getPlayback": {
        "prefix": "getPlayback() → {PlayBackControl}",
        "body": "getPlayback()",
        "description": "Get the UI state object for controlling the playback."
    },
    "getProject": {
        "prefix": "getProject() → {Project}",
        "body": "getProject()",
        "description": "Get the currently open project."
    },
    "pitch2freq": {
        "prefix": "pitch2freq(p) → {number}",
        "body": "pitch2freq(${1:p})",
        "description": "Convert a MIDI number (semitones, where C4 is 60) to a frequency in Hz. Conversions between musical and physical time in the context of a project are done by TimeAxis."
    },
    "quarter2Blick": {
        "prefix": "quarter2Blick(q) → {number}",
        "body": "quarter2Blick(${1:q})",
        "description": "Convert q from number of quarters into number of blick. Equivalent to q * SV.QUARTER. Conversions between musical and physical time in the context of a project are done by TimeAxis."
    },
    "seconds2Blick": {
        "prefix": "seconds2Blick(s, bpm) → {number}",
        "body": "seconds2Blick(${1:s}, ${2:bpm})",
        "description": "Convert s from seconds into blicks with the specified beats per minute bpm. Equivalent to s / 60 * bpm * SV.QUARTER. Conversions between musical and physical time in the context of a project are done by TimeAxis."
    },
    "setHostClipboard": {
        "prefix": "setHostClipboard(text)",
        "body": "setHostClipboard(${1:text})",
        "description": "Set the system clipboard."
    },
    "setTimeout": {
        "prefix": "setTimeout(timeOut, callback)",
        "body": "setTimeout(${1:timeOut}, ${2:callback})",
        "description": "Schedule a delayed call to callback after timeOut milliseconds. After calling setTimeout, the script will continue instead of immediately executing callback. The callback function is pushed onto a queue and delayed. This is not a preemptive callback, i.e. the execution of callback will not interrupt the currently running task."
    },
    "showCustomDialog": {
        "prefix": "showCustomDialog(form) → {object}",
        "body": "showCustomDialog(${1:form})",
        "description": "The synchronous version of SV#showCustomDialogAsync that blocks the script execution until the user closes the dialog. It returns the inputs (the completed form) from the user."
    },
    "showCustomDialogAsync": {
        "prefix": "showCustomDialogAsync(form, callback)",
        "body": "showCustomDialogAsync(${1:form}, ${2:callback})",
        "description": "Display a custom dialog defined in form, without blocking the script execution. callback will be invoked once the dialog is closed. The callback function takes one argument which contains the results. See Custom Dialogs for more information."
    },
    "showInputBox": {
        "prefix": "showInputBox(title, message, defaultText) → {string}",
        "body": "showInputBox(${1:title}, ${2:message}, ${3:defaultText})",
        "description": "The synchronous version of SV#showInputBoxAsync that blocks the script execution until the user closes the dialog. It returns the text input from the user."
    },
    "showInputBoxAsync": {
        "prefix": "showInputBoxAsync(title, message, defaultText, callback)",
        "body": "showInputBoxAsync(${1:title}, ${2:message}, ${3:defaultText}, ${4:callback})",
        "description": "Display a dialog with a text box and an \"OK\" button, without blocking the script execution. callback will be invoked once the dialog is closed. The callback function takes one string argument that is the content of the text box."
    },
    "showMessageBox": {
        "prefix": "showMessageBox(title, message)",
        "body": "showMessageBox(${1:title}, ${2:message})",
        "description": "The synchronous version of SV#showMessageBoxAsync that blocks the script execution until the user closes the message box."
    },
    "showMessageBoxAsync": {
        "prefix": "showMessageBoxAsync(title, message, callback)",
        "body": "showMessageBoxAsync(${1:title}, ${2:message}, ${3:callback})",
        "description": "Cause a message box to pop up without blocking the script execution. If a callback is given, it is invoked once the message box is closed. The callback function takes no argument."
    },
    "showOkCancelBox": {
        "prefix": "showOkCancelBox(title, message) → {boolean}",
        "body": "showOkCancelBox(${1:title}, ${2:message})",
        "description": "The synchronous version of SV#showOkCancelBoxAsync that blocks the script execution until the user closes the message box. It returns true if \"OK\" button is pressed."
    },
    "showOkCancelBoxAsync": {
        "prefix": "showOkCancelBoxAsync(title, message, callback)",
        "body": "showOkCancelBoxAsync(${1:title}, ${2:message}, ${3:callback})",
        "description": "Display a message box with an \"OK\" button and a \"Cancel\" button, without blocking the script execution. callback will be invoked once the message box is closed. The callback function takes one boolean argument that is true if \"OK\" button is pressed."
    },
    "showYesNoCancelBox": {
        "prefix": "showYesNoCancelBox(title, message) → {string}",
        "body": "showYesNoCancelBox(${1:title}, ${2:message})",
        "description": "The synchronous version of SV#showYesNoCancelBoxAsync that blocks the script execution until the user closes the message box. It returns \"yes\", \"no\" or \"cancel\"."
    },
    "showYesNoCancelBoxAsync": {
        "prefix": "showYesNoCancelBoxAsync(title, message, callback)",
        "body": "showYesNoCancelBoxAsync(${1:title}, ${2:message}, ${3:callback})",
        "description": "Display a message box with a \"Yes\" button, an \"No\" button and a \"Cancel\" button, without blocking the script execution. callback will be invoked once the message box is closed. The callback function takes one string argument that can be \"yes\", \"no\" or \"cancel\"."
    },
    "T": {
        "prefix": "T(text) → {string}",
        "body": "T(${1:text})",
        "description": "Get a localized version of text based on the current UI language settings. See Localization for more information."
    },
    "addMeasureMark": {
        "prefix": "addMeasureMark(measure, nomin, denom)",
        "body": "addMeasureMark(${1:measure}, ${2:nomin}, ${3:denom})",
        "description": "Insert a nomin/denom measure mark at position measure (a measure number). If a measure mark exists at measure, update the information."
    },
    "addTempoMark": {
        "prefix": "addTempoMark(b, bpm)",
        "body": "addTempoMark(${1:b}, ${2:bpm})",
        "description": "Insert a tempo mark with beats per minute of bpm at position b (blicks). If a tempo mark exists at position b, update the BPM."
    },
    "getAllMeasureMarks": {
        "prefix": "getAllMeasureMarks() → {array}",
        "body": "getAllMeasureMarks()",
        "description": "Get all measure marks in this TimeAxis. See TimeAxis#getMeasureMarkAt."
    },
    "getAllTempoMarks": {
        "prefix": "getAllTempoMarks() → {array}",
        "body": "getAllTempoMarks()",
        "description": "Get all tempo marks in this TimeAxis. See TimeAxis#getTempoMarkAt."
    },
    "getBlickFromSeconds": {
        "prefix": "getBlickFromSeconds(t) → {number}",
        "body": "getBlickFromSeconds(${1:t})",
        "description": "Convert physical time t (second) to musical time (blicks)."
    },
    "getMeasureAt": {
        "prefix": "getMeasureAt(b) → {number}",
        "body": "getMeasureAt(${1:b})",
        "description": "Get the measure number at position b (blicks)."
    },
    "getMeasureMarkAt": {
        "prefix": "getMeasureMarkAt(measureNumber) → {object}",
        "body": "getMeasureMarkAt(${1:measureNumber})",
        "description": "Get the measure mark at measure measureNumber. The returned object contains the following properties."
    },
    "getSecondsFromBlick": {
        "prefix": "getSecondsFromBlick(b) → {number}",
        "body": "getSecondsFromBlick(${1:b})",
        "description": "Convert musical time b (blicks) to physical time (seconds)."
    },
    "getMeasureMarkAtBlick": {
        "prefix": "getMeasureMarkAtBlick(b) → {object}",
        "body": "getMeasureMarkAtBlick(${1:b})",
        "description": "Get the measure mark that is effective at position b (blicks). For the returned object, see TimeAxis#getMeasureMarkAt."
    },
    "getTempoMarkAt": {
        "prefix": "getTempoMarkAt(b) → {TempoMark}",
        "body": "getTempoMarkAt(${1:b})",
        "description": "Get the tempo mark that is effective at position b (blicks). The returned object contains the following properties; position, positionSeconds, bpm."
    },
    "removeMeasureMark": {
        "prefix": "removeMeasureMark(measure) → {boolean}",
        "body": "removeMeasureMark(${1:measure})",
        "description": "Remove the measure mark at measure number measure. If a measure mark exists at measure, return true."
    },
    "removeTempoMark": {
        "prefix": "removeTempoMark(b) → {boolean}",
        "body": "removeTempoMark(${1:b})",
        "description": "Remove the tempo mark at position b (blicks). If a tempo mark exists at position b, return true."
    },
    "addGroupReference": {
        "prefix": "addGroupReference(group) → {number}",
        "body": "addGroupReference(${1:group})",
        "description": "Add a NoteGroupReference to this Track and return the index of the added group. It keeps all groups sorted by onset position."
    },
    "getDisplayColor": {
        "prefix": "getDisplayColor() → {string}",
        "body": "getDisplayColor()",
        "description": "Get the track's color as a hex string."
    },
    "getDisplayOrder": {
        "prefix": "getDisplayOrder() → {number}",
        "body": "getDisplayOrder()",
        "description": "Get the display order of the track inside the parent Project. A track's display order can be different from its storage index. The order of tracks as displayed in arrangement view is always based on the display order."
    },
    "getGroupReference": {
        "prefix": "getGroupReference(index) → {NoteGroupReference}",
        "body": "getGroupReference()",
        "description": "Get the index-th NoteGroupReference. The first is always the main group, followed by groups that refer to NoteGroup in the project library. The groups are sorted in ascending onset positions."
    },
    "getNumGroups": {
        "prefix": "getNumGroups() → {number}",
        "body": "getNumGroups()",
        "description": "Get the number of NoteGroupReference in this Track, including the main group."
    },
    "isBounced": {
        "prefix": "isBounced() → {boolean}",
        "body": "isBounced()",
        "description": "An option for whether or not to be exported to files, shown in Render Panel."
    },
    "removeGroupReference": {
        "prefix": "removeGroupReference(index)",
        "body": "removeGroupReference(${1:index})",
        "description": "Remove the index-th NoteGroupReference from this Track."
    },
    "setBounced": {
        "prefix": "setBounced(enabled)",
        "body": "setBounced(${1:enabled})",
        "description": "Set whether or not to have the Track exported to files. See Track#isBounced."
    },
    "setDisplayColor": {
        "prefix": "setDisplayColor(colorStr)",
        "body": "setDisplayColor()",
        "description": "Set the display color of the Track to a hex string."
    },
    "clearNotes": {
        "prefix": "clearNotes() → {boolean}",
        "body": "clearNotes()",
        "description": "Unselect all notes. Return true if the selection has changed."
    },
    "getSelectedNotes": {
        "prefix": "getSelectedNotes() → {array}",
        "body": "getSelectedNotes()",
        "description": "Get an array of selected Note following the order of selection."
    },
    "hasSelectedNotes": {
        "prefix": "hasSelectedNotes() → {boolean}",
        "body": "hasSelectedNotes()",
        "description": "Check if there is at least one Note selected."
    },
    "selectGroup": {
        "prefix": "selectGroup(reference)",
        "body": "selectGroup(${1:reference})",
        "description": "Add a NoteGroupReference to the selection. The argument must be part of the currently open project."
    },
    "selectNote": {
        "prefix": "selectNote(note)",
        "body": "selectNote(${1:note})",
        "description": "Select a Note. The note must be inside the current NoteGroupReference opened in the piano roll (see MainEditorView#getCurrentGroup)."
    },
    "unselectNote": {
        "prefix": "unselectNote(note) → {boolean}",
        "body": "unselectNote(${1:note)",
        "description": "Unselect a Note. Return true if the selection has changed."
    }
}